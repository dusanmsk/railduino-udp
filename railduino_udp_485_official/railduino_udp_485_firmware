/*
    Copyright (C) 2017  Dusan Zatkovsky, Ing. Pavel Sedlacek
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*
   Wire syntax:
   signals:
     DS18B20 1wire sensor packet:    rail1 1w 2864fc3008082 25.44
     DS2438 1wire sensor packet:     rail1 1w 2612c3102004f 25.44 1.23 0.12
     digital input connected:        rail1 i1 1
     digital input disconnected:     rail1 i1 0
     analog input state:             rail1 ai1 520
   commands:
     relay on command:               rail1 r12 on
     relay off command:              rail1 r5 off
     pwm output command:             rail1 pwm1 255
     digital inputs configuration:   rail1 cfg repeat=4,5,8,12 period=5000
*/

#define repeatedInputsSleepRatio 5

#include <OneWire.h>
#include <DS2438.h>
#include <Dhcp.h>
#include <Dns.h>
#include <Ethernet.h>
#include <EthernetClient.h>
#include <EthernetServer.h>
#include <EthernetUdp.h>

byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0}; // last byte will be derived from board address
unsigned int listenPort = 44444;
unsigned int sendPort = 55554;
unsigned int loxonePort = 55555;
IPAddress listenIpAddress;
IPAddress sendIpAddress(255, 255, 255, 255);

#define inputPacketBufferSize UDP_TX_PACKET_MAX_SIZE
char inputPacketBuffer[UDP_TX_PACKET_MAX_SIZE];

#define outputPacketBufferSize 100
char outputPacketBuffer[outputPacketBufferSize];

#define SSerialTxControl 8

#define dbg(x) Serial.println(x);
//#define dbg(x) ;

EthernetUDP udpRecv;
EthernetUDP udpSend;
 
#define numOfRelays 12
int relayPins[] = {39, 41, 43, 45, 47, 49, 23, 25, 27, 29, 31, 33};

#define numOfPWMs 4
int PWMPins[] = {11, 13, 12, 7};

#define numOfAnaInputs 3
int analogPins[] = {58, 59, 62};
int analogStatus[numOfAnaInputs];

#define numOfInputs 24
int inputPins[] = {36, 34, 48, 46, 69, 68, 67, 66, 44, 42, 40, 38, 6, 5, 3, 2, 14, 15, 16, 17, 24, 26, 28, 30};
int inputStatus[numOfInputs];

int statusLedPin = 32;

int boardAddress = 0;
String boardAddressStr;

String relayOnCommands[numOfRelays];
String relayOffCommands[numOfRelays];
String PWMCommand[numOfPWMs];
String boardAddressRailStr;
String allBoardAddressRailStr = "rail*";

unsigned long LastTime = 0;  

class Timer {
private:
    unsigned long timestampLastHitMs;
    unsigned long sleepTimeMs;
public:
    boolean isOver();
    void sleep(unsigned long sleepTimeMs);
};

/**
 * Return true if specified time passed from last pass, else return false
*/
boolean Timer::isOver() {
    if (millis() - timestampLastHitMs < sleepTimeMs) {
        return false;
    }
    timestampLastHitMs = millis();
    return true;
}

void Timer::sleep(unsigned long sleepTimeMs) {
    this->sleepTimeMs = sleepTimeMs;
    timestampLastHitMs = millis();
}


Timer On;
Timer Off;

Timer statusLedTimer;

void blinkStatusLed(int timeOn) {
    digitalWrite(statusLedPin, 255);
    statusLedTimer.sleep(timeOn);
}

void turnOffStatusLed() {
    if (statusLedTimer.isOver()) {
        digitalWrite(statusLedPin, 0);
    }
}

OneWire ds(9);
byte oneWireData[12];
byte oneWireAddr[8];
enum OneWireConversationState {SEARCH, INIT, READ};
OneWireConversationState oneWireConversationState = SEARCH;
#define NumberOfSensors 6
byte readstage = 0;
byte resolution = 11;
byte sensors[NumberOfSensors][8], SensorsPresent, DS2438count, DS18B20count;
byte sensors2438[NumberOfSensors][8], sensors18B20[NumberOfSensors][8];
DS2438 ds2438(&ds);


void setup() {

   // blinkStatusLed(1000);

    Serial.begin(9600);
    Serial1.begin(115200);

    /* COMMON settings */
    for (int i = 0; i < numOfRelays; i++) {
        pinMode(relayPins[i], OUTPUT);
    }

    for (int i = 0; i < numOfPWMs; i++) {
        pinMode(PWMPins[i], OUTPUT);
    }

    for (int i = 0; i < numOfAnaInputs; i++) {
        pinMode(analogPins[i], INPUT);
    }
    
    pinMode(statusLedPin, OUTPUT);  // LED
    pinMode(SSerialTxControl, OUTPUT);
    digitalWrite(SSerialTxControl, 0); // receiving RS485

    /* digital inputs settings */
    for (int i = 0; i < numOfInputs; i++) {
        pinMode(inputPins[i], INPUT_PULLUP);
        inputStatus[i] = 0;
    }

    /* DIP SWITCH settings */
    pinMode(57, INPUT);
    pinMode(56, INPUT);
    pinMode(55, INPUT);
    pinMode(54, INPUT);


    // read address from dip switch
    if (!digitalRead(54)) { boardAddress |= 1; }
    if (!digitalRead(55)) { boardAddress |= 2; }
    if (!digitalRead(56)) { boardAddress |= 4; }
    if (!digitalRead(57)) { boardAddress |= 8; }

    boardAddressStr = String(boardAddress);

    // generate command templates (speedup matching when receiving udp packet)
    for (int i = 0; i < numOfRelays; i++) {
        relayOnCommands[i] = "r" + String(i + 1, DEC) + " on";
        relayOffCommands[i] = "r" + String(i + 1, DEC) + " off";
    }
    
    for (int i = 0; i < numOfPWMs; i++) {
        PWMCommand[i] = "pwm" + String(i + 1, DEC);
    }

    boardAddressRailStr = "rail" + String(boardAddress);

    // initialize ethernet
    mac[5] = (0xED + boardAddress);
    listenIpAddress = IPAddress(192, 168, 150, 150 + boardAddress);
    Ethernet.begin(mac, listenIpAddress);
    udpRecv.begin(listenPort);
    udpSend.begin(sendPort);

    dbg("Railduino address: ");
    dbg(boardAddressStr);
    dbg(listenIpAddress);

    for (int i = 0; i < numOfRelays; i++) {
        setRelay(i+1, 0);
    }

    for (int i = 0; i < numOfPWMs; i++) {
        setPWM(i+1, 0);
    }
    
    lookUpSensors(); 

    On.sleep(53);
    Off.sleep(950);
}

void loop() {

 

    if (Off.isOver()) {
        digitalWrite(statusLedPin,155);
    }
  
    if (On.isOver()) {
        digitalWrite(statusLedPin,0);
    }   
  

    // read inputs and send updates
    // TODO zasekava sa (!!)
    readInputs();

    // process relay commands
    processCommands();

    // process onewire
    processOnewire();

    //processRepeatedInputs();
    
   // turnOffStatusLed();

   // delay(10);

}

Timer repeatedInputsTimer;
void processRepeatedInputs() {
    if (!repeatedInputsTimer.isOver()) {
        return;
    }

    dbg("TODO repeated inputs");

    repeatedInputsTimer.sleep(repeatedInputsSleepRatio * 1000);
}


String oneWireAddressToString(byte addr[]) {
    String s = "";
    for (int i = 0; i < 8; i++) {
        s += String(addr[i], HEX);
    }
    return s;
}

void lookUpSensors(){
  byte i=0, j=0, k=1, l=0, m=1, crcok = 0, sensors_count = 0;
  while ((j < NumberOfSensors) && (ds.search(sensors[j]))){
    if (!OneWire::crc8(sensors[j], 7) != sensors[j][7]){
        if (sensors[j][0] == 38){
          for (l=0;l<8;l++){ sensors2438[k][l]=sensors[j][l]; }  
          k++;  
        } else {
          for (l=0;l<8;l++){ sensors18B20[m][l]=sensors[j][l]; }
          m++;
          dssetresolution(ds,sensors[j],resolution);
        }
    }
    j++;
  }
  SensorsPresent = j;
  DS2438count = k-1;
  DS18B20count = m-1;
}

void dssetresolution(OneWire ow, byte addr[8], byte resolution) {
  byte resbyte = 0x1F;
  if (resolution == 12){ resbyte = 0x7F; }
  else if (resolution == 11) { resbyte = 0x5F; }
  else if (resolution == 10) { resbyte = 0x3F; }

  ow.reset();
  ow.select(addr);
  ow.write(0x4E);         // Write scratchpad
  ow.write(0);            // TL
  ow.write(0);            // TH
  ow.write(resbyte);         // Configuration Register
  ow.write(0x48);         // Copy Scratchpad
}

void dsconvertcommand(OneWire ow, byte addr[8]){
  ow.reset();
  ow.select(addr);
  ow.write(0x44,1);         // start conversion, with parasite power on at the end
}

float dsreadtemp(OneWire ow, byte addr[8]) {
  int i;
  byte data[12];
  float celsius;
  ow.reset();
  ow.select(addr);
  ow.write(0xBE);         // Read Scratchpad
  for ( i = 0; i < 9; i++) {           // we need 9 bytes
    data[i] = ow.read();
  }

  int TReading = (data[1] << 8) | data[0];
  int SignBit = TReading & 0x8000;  // test most sig bit
  
  if (SignBit)                     // negative temperature
  {
    TReading = (TReading ^ 0xffff) + 1; // 2's comp
    celsius = -1 * TReading * 0.0625;
  } else {
    celsius = TReading * 0.0625;
  }
  
  return celsius;
}

Timer oneWireTimer;

void processOnewire() {

    
    if (!oneWireTimer.isOver()) {
        return;  
    }

   dbg("processing onewire");
   oneWireTimer.sleep(30000);   
   
   byte m=1, n=1, o=0;
     
     while ((m <= DS2438count)){              
        
        ds2438.begin();
        ds2438.update(sensors2438[m]);
        
        if (ds2438.isError()) {
         ;
        } else {
          float TempArrayDS2438[15];
          
          TempArrayDS2438[m] = ds2438.getTemperature(); 
        //  sendMSG("1w " + oneWireAddressToString(sensors2438[m]) + " temp " + String(TempArrayDS2438[m], 2));
          
          TempArrayDS2438[m+1] = ds2438.getVoltage(DS2438_CHA);
        //  sendMSG("1w " + oneWireAddressToString(sensors2438[m]) + " vad1 " + String(TempArrayDS2438[m+1], 2));
           
          TempArrayDS2438[m+2] = ds2438.getVoltage(DS2438_CHB);
          sendMSG("1w " + oneWireAddressToString(sensors2438[m]) + " " + String(TempArrayDS2438[m], 2) + " " + String(TempArrayDS2438[m+1], 2) + " " + String(TempArrayDS2438[m+2], 2));
       }
       
        m++;
     }
       
    while ((n <= DS18B20count)){
           
      if (readstage == 0){                                     // phase 1 - converting values in DS18B20
        byte j=1;
        while (j <= DS18B20count){
          dsconvertcommand(ds,sensors18B20[j]);
          j++;
        }
        readstage++;
      }
      else {                                                    // phase 2 - reading values
        if (ds.read()) {  
          byte j=1;
          float TempArrayDS18B20[5];
          while (j <= DS18B20count){                           
            TempArrayDS18B20[j] = dsreadtemp(ds,sensors18B20[j]);
             j++;
          }
          readstage=0; 
      
        }
      }   
    n++;   
   }

}

Timer analogTimer;

void readInputs() {
    
    for (int i = 0; i < numOfInputs; i++) {
        int pin = inputPins[i];
        int value = digitalRead(pin);
        int oldValue = inputStatus[i];
        inputStatus[i] = value;
        // note values are inverted due to pullup
        if (value < oldValue) {
            sendInputOn(i + 1);
        }
        if (value > oldValue) {
            sendInputOff(i + 1);
        }
    }
    
    if (!analogTimer.isOver()) {
        return;  
    }

    dbg("processing analog inputs");
    analogTimer.sleep(500);
    for (int i = 0; i < numOfAnaInputs; i++) {
        int pin = analogPins[i];
        float value = analogRead(pin);
        float oldValue = analogStatus[i];
        analogStatus[i] = value;
        if (value != oldValue) {
            sendAnaInput(i+1,value);
        }
    } 
    
}

void sendInputOn(int input) {
    sendMSG("i" + String(input, DEC) + " 1");
}

void sendInputOff(int input) {
    sendMSG("i" + String(input, DEC) + " 0");
}

void sendAnaInput(int input, float value) {
    sendMSG("ai" + String(input, DEC) + " " + String(value, 2));
}

void sendMSG(String message) {
    message = "rail" + boardAddressStr + " " + message;
    udpSend.beginPacket(sendIpAddress, loxonePort);
    message.toCharArray(outputPacketBuffer, outputPacketBufferSize);
    udpSend.write(outputPacketBuffer, message.length());
    udpSend.endPacket();
    
    digitalWrite(SSerialTxControl, 1);     
    Serial1.print(message + "\n");
    delay(10);    
    digitalWrite(SSerialTxControl, 0);
        
    dbg(message);
}

void setRelay(int relay, int value) {
    if (relay > numOfRelays) {
        return;
    }
    dbg("Writing to relay " + String(relay) + " value " + String(value));
    digitalWrite(relayPins[relay], value);
}

void setPWM(int pwm, int value) {
    if (pwm > numOfPWMs) {
        return;
    }
    dbg("Writing to PWM output " + String(pwm) + " value " + String(value));
    analogWrite(PWMPins[pwm], value);
}

String receivePacket() {
    String cmd = "";    
    
    while (Serial1.available()) {    
      cmd = Serial1.readStringUntil('\n'); 
     // dbg(cmd);
      if (cmd.startsWith(boardAddressRailStr)) {
            cmd.replace(boardAddressRailStr, "");
            cmd.trim();
            return cmd;
        }
    }     

    int packetSize = udpRecv.parsePacket();
    if (packetSize) {
//        blinkStatusLed(20);
        memset(inputPacketBuffer, 0, sizeof(inputPacketBuffer));
        udpRecv.read(inputPacketBuffer, inputPacketBufferSize);
        String cmd = String(inputPacketBuffer);
       // dbg(cmd);
        if (cmd.startsWith(boardAddressRailStr)) {
            cmd.replace(boardAddressRailStr, "");
            cmd.trim();
            return cmd;
        } else if (cmd.startsWith(allBoardAddressRailStr)) {
            cmd.replace(allBoardAddressRailStr, "");
            cmd.trim();
            return cmd;
        }
    }
    return "";
}


void processConfigurationCommand(String cmd) {
    // TODO
}


void processPingCommand(String cmd) {
    sendMSG("pong");
}

void processCommands() {
    String cmd = receivePacket();
    if (cmd != "") {
        if (cmd.startsWith("cfg")) {
            processConfigurationCommand(cmd);
        } else if (cmd.startsWith("ping")) {
            processPingCommand(cmd);
        } else if (cmd.startsWith("r")) {
            for (int i = 0; i < numOfRelays; i++) {
                if (cmd == relayOnCommands[i]) {
                    setRelay(i+1, 1);
                } else if (cmd == relayOffCommands[i]) {
                    setRelay(i+1, 0);
                }
            }
        } else if (cmd.startsWith("pwm")) {
            String PWMvalue = cmd.substring(5);
             for (int i = 0; i < numOfPWMs; i++) {
                if (cmd.substring(0,4) == PWMCommand[i]) {
                    setPWM(i+1, PWMvalue.toInt());
                } 
            }
        }
    }
}
